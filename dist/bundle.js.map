{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;;;AAAO;AACA;AACA;AACA;AACA;;;;;;;;;;;ACJP;;;;;;;;;;;;;;;ACAA;AACA;AACO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACV8C;AACM;AACR;AAC5C;AACA;AACO;AACP,yBAAyB,2DAAY;AACrC;AACA,eAAe,iEAAe;AAC9B,KAAK;AACL,eAAe,yDAAU;AACzB;AACA;;;;;;;;;;;;;;;;;ACZmD;AACf;AACpC;AACA;AACA;AACO;AACP;AACA,yBAAyB,iDAAM;AAC/B;AACA,mCAAmC,QAAQ,GAAG,OAAO,OAAO,qDAAa,CAAC;AAC1E;AACA;AACA;AACA,KAAK;AACL,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA,4BAA4B,qBAAqB,OAAO,qBAAqB;AAC7E;AACA,KAAK;AACL,mBAAmB,IAAI;AACvB;AACA;;;;;;;;;;;;;;;;AC1B+C;AACT;AACtC;AACA;AACA;AACO;AACP;AACA,mCAAmC,WAAW,IAAI,UAAU,uBAAuB,iDAAS,CAAC;AAC7F;AACA,QAAQ,mDAAQ;AAChB;AACA,KAAK;AACL,yBAAyB,IAAI;AAC7B;AACA;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,0BAA0B,IAAI;AAC9B;AACA;;;;;;;;;;;;;;;;;AChB+C;AACT;AACtC;AACA;AACA;AACO;AACP;AACA,mCAAmC,WAAW,OAAO,iDAAS,CAAC,KAAK,UAAU;AAC9E;AACA,QAAQ,mDAAQ;AAChB;AACA,KAAK;AACL,yBAAyB,IAAI;AAC7B;AACA;AACA;;;;;;;;;;;;;;;;ACfoC;AACpC;AACA;AACO;AACP,mBAAmB,iDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;ACbA;AACO;AACP;AACA;AACA,mBAAmB,mCAAmC;AACtD,8BAA8B,QAAQ;AACtC,KAAK;AACL;AACA;;;;;;;;;;;;;;ACRA;AACO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN,mBAAmB,IAAI;AACvB;AACA;;;;;;;;;;;;;;;;;ACTmD;AACf;AACpC;AACA;AACA;AACO;AACP;AACA,yBAAyB,iDAAM;AAC/B;AACA,mCAAmC,eAAe,GAAG,OAAO,OAAO,qDAAa,CAAC;AACjF;AACA;AACA;AACA,KAAK;AACL,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA,4BAA4B,qBAAqB,OAAO,qBAAqB;AAC7E;AACA,KAAK;AACL,mBAAmB,IAAI;AACvB;AACA;;;;;;;;;;;;;;;;;AC1B8C;AACU;AACJ;AACpD;AACA;AACA;AACO;AACP,0BAA0B,iEAAe;AACzC,UAAU,2DAAY;AACtB,qBAAqB,qEAAiB;AACtC,4BAA4B,2DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UCxEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACN4B;AAC5B;AACwC;AACQ;AACN;AAC1C;AACA;AACA;AACA,EAAE,uDAAY,CAAC,yDAAa,EAAE,iDAAS;AACvC,CAAC,E","sources":["webpack://Client/./mockJSEnv.js","webpack://Client/./src/client/styles/main.scss?721e","webpack://Client/./src/client/js/checkForDate.js","webpack://Client/./src/client/js/forecastOrCurrent.js","webpack://Client/./src/client/js/forecastWeather.js","webpack://Client/./src/client/js/geoFetch.js","webpack://Client/./src/client/js/listener.js","webpack://Client/./src/client/js/pixFetch.js","webpack://Client/./src/client/js/pixUpdate.js","webpack://Client/./src/client/js/postData.js","webpack://Client/./src/client/js/secondConverter.js","webpack://Client/./src/client/js/weatherFetch.js","webpack://Client/./src/client/js/weatherUpdate.js","webpack://Client/webpack/bootstrap","webpack://Client/webpack/runtime/define property getters","webpack://Client/webpack/runtime/hasOwnProperty shorthand","webpack://Client/webpack/runtime/make namespace object","webpack://Client/./src/client/js/index.js"],"sourcesContent":["export const weatherApiKey = 'b8bcfc4d5ff94729ad345008167d0424';\r\nexport const geoApiKey = 'cole200406';\r\nexport const pixApiKey = '32251964-d3a8f6eb7f41a7da2ca59e329';\r\nexport const formDate = '2023-01-11T22:41:38.540Z'\r\nexport const formInput = \"raleigh\";","// extracted by mini-css-extract-plugin\nexport {};","// Uses date Input from user entered date, defines anything over a weeks time,\r\n// then returns true if the date Input is greater than a week, and false if it's not\r\nexport const checkForDate = async (dateInput) => {\r\n    let overWeek = Date.now() + (1000 * 60 * 60 * 24 * 7)\r\n    if (dateInput > overWeek) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n","import { checkForDate } from \"./checkForDate\";\r\nimport { forecastWeather } from \"./forecastWeather\";\r\nimport { weatherAPI } from \"./weatherFetch\";\r\n\r\n//Takes the defined \"Week Away\" from checkForDate.js, essentially if checkForDate returned true it will fetch the forecast api, if not it will run the current weather api \r\nexport const forecastOrCurrent = async (dateInput, formInput) => {\r\n    let weekAway = await checkForDate(dateInput);\r\n    if (weekAway) {\r\n        return forecastWeather(formInput, dateInput);\r\n    }else {\r\n        return weatherAPI(formInput);\r\n    }\r\n}","import { weatherApiKey } from \"../../../mockJSEnv\";\r\nimport { geoAPI } from \"./geoFetch\";\r\nconst baseUrl = 'http://api.weatherbit.io/v2.0/forecast/daily';\r\n\r\n//Fetches forecast weather data and returns it, the data is weather for a specific location after a weeks time\r\nexport const forecastWeather = async (formInput, dateInput) => {\r\n    try{\r\n        let data = await geoAPI(formInput);\r\n        let latlon = await returnLatLon(data)\r\n        const res = await fetch(`${baseUrl}?${latlon}&key=${weatherApiKey}&include=minutely`);\r\n        const apiData = await res.json();\r\n        console.log(apiData)\r\n        return (apiData);\r\n    }catch (err) {\r\n        return `Failed ${err}`\r\n    }\r\n}\r\n\r\n//Needed to run forecastWeather, this returns the coordinates for the user entered location from geoAPI\r\nexport const returnLatLon = async (data) => {\r\n    try {\r\n        let latlon = `lat=${data.geonames[0].lat}&lon=${data.geonames[0].lng}`;\r\n        return latlon\r\n    }catch (err){\r\n        `Failed: ${err}`\r\n    }\r\n}","import { geoApiKey } from \"../../../mockJSEnv\";\r\nimport { postData } from \"./postData\";\r\nconst geoBaseUrl = \"https://secure.geonames.org/searchJSON?\"\r\n\r\n//Fetches coordinates from api and returns it, needed to make any of the weather api's work since they require coordinates\r\nexport const geoAPI = async (formInput) => {\r\n    try{\r\n        const res = await fetch(`${geoBaseUrl}q=${formInput}&maxRows=10&username=${geoApiKey}`);\r\n        const apiData = await res.json();\r\n        postData(apiData);\r\n        return (apiData);\r\n    }catch (err) {\r\n        return `Failed ${err}`\r\n    }\r\n}","//Define form\r\nlet form = document.getElementById(\"inputForm\");\r\n\r\n//EventListener used in index, listens for form to be submitted\r\nexport const formListener = async (weatherUpdate, pixUpdate) => {\r\n    try {\r\n      form.addEventListener(\"submit\", (event) => {\r\n        event.preventDefault();\r\n        let formInput = document.getElementById('placeInput').value;\r\n        let formDate = document.getElementById('dateInput').value;\r\n        weatherUpdate(formDate, formInput);\r\n        pixUpdate(formInput);\r\n      })\r\n    } catch (err) {\r\n        return `Failed: ${err}`\r\n    }\r\n}\r\n","import { pixApiKey } from \"../../../mockJSEnv\";\r\nimport { postData } from \"./postData\";\r\nconst pixBaseURL = \"https://pixabay.com/api/\"\r\n\r\n// Fetches api Data and returns it, returns pictures of location for UI\r\nexport const pixAPI = async (formInput) => {\r\n    try{\r\n        const res = await fetch(`${pixBaseURL}?key=${pixApiKey}&q=${formInput}&image_type=photo`);\r\n        const apiData = await res.json();\r\n        postData(apiData);\r\n        return (apiData);\r\n    }catch (err) {\r\n        return `Failed ${err}`\r\n    }\r\n}\r\n\r\n","import { pixAPI } from \"./pixFetch\";\r\n\r\n// Fetch date from pixApi then take two img sources, make img's in the html for them then display them.\r\nexport const pixUpdate = async (formInput) => {\r\n  let data = await pixAPI(formInput);\r\n  let pictures = [data.hits[0].previewURL, data.hits[1].previewURL];\r\n  pictures.forEach(picture => {\r\n    let div = document.getElementById('pictures');\r\n    let img = document.createElement('img');\r\n    img.src = picture;\r\n    img.classList.add('formPictures');\r\n    div.appendChild(img);\r\n  })\r\n};\r\n","//This is ran at the end of every api and sends all of their data to the server\r\nexport const postData = async (apiData) => {\r\n    fetch(\"http://localhost:8000/apiData\", {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\"},\r\n        body: JSON.stringify({apiData}),\r\n    })\r\n    .then((response) => response.json())\r\n};","//Needed to take user entered date and turn it into a number, if it was left as a string checkForDate would not work\r\nexport const secondConverter = async (formDate) => {\r\n    try {\r\n        let date = new Date(formDate);\r\n        let dateInput = date.getTime()\r\n        return dateInput\r\n    } catch (err) {\r\n        `Failed: ${err}`\r\n    }\r\n}","import { weatherApiKey } from \"../../../mockJSEnv\";\r\nimport { geoAPI } from \"./geoFetch\";\r\nconst weatherBaseUrl = \" http://api.weatherbit.io/v2.0/current\"\r\n\r\n////Fetches current weather data and returns it, the data is weather for a specific location within a weeks time\r\nexport const weatherAPI = async (formInput) => {\r\n    try{\r\n        let data = await geoAPI(formInput);\r\n        let latlon = await returnLatLon(data)\r\n        const res = await fetch(`${weatherBaseUrl}?${latlon}&key=${weatherApiKey}&include=minutely`);\r\n        const apiData = await res.json();\r\n        console.log(apiData)\r\n        return (apiData);\r\n    }catch (err) {\r\n        return `Failed ${err}`\r\n    }\r\n}\r\n\r\n//Needed to run weatherAPI, this returns the coordinates for the user entered location from geoAPI\r\nexport const returnLatLon = async (data) => {\r\n    try {\r\n        let latlon = `lat=${data.geonames[0].lat}&lon=${data.geonames[0].lng}`;\r\n        return latlon\r\n    }catch (err){\r\n        `Failed: ${err}`\r\n    }\r\n}","import { checkForDate } from \"./checkForDate\";\r\nimport { forecastOrCurrent } from \"./forecastOrCurrent\";\r\nimport { secondConverter } from './secondConverter';\r\n\r\n//If data is within a week make a card that displays current temp, if it's sunny or rainy or snowy or mix, and the date. If it is over a week do the same thing except take min and max temp for 7 days and average them.\r\n//Then display the card depending on the date entered.\r\nexport const weatherUpdate = async (formDate, formInput) => {\r\n    let dateInput = await secondConverter(formDate);\r\n    await checkForDate(dateInput);\r\n    let data = await forecastOrCurrent(dateInput, formInput);\r\n    let trueOrFalse = await checkForDate();\r\n    if (trueOrFalse){\r\n      let minAverage = [data.data[0].min_temp + data.data[1].min_temp +data.data[2].min_temp + data.data[3].min_temp + data.data[4].min_temp + data.data[5].min_temp + data.data[6].min_temp / 7]\r\n      let maxAverage = [data.data[0].max_temp + data.data[1].max_temp +data.data[2].max_temp + data.data[3].max_temp + data.data[4].max_temp + data.data[5].max_temp + data.data[6].max_temp / 7]\r\n      let day = data.data[0]\r\n      let div = document.getElementById('weather');\r\n      let card = document.createElement('div');\r\n      card.classList.add('cards');\r\n      let date = document.createElement('h3');\r\n      date.id = \"date\";\r\n      date.innerHTML = day.datetime;\r\n      let img = document.createElement('img');\r\n    \r\n      if (day.precip == 0 & day.snow == 0) {\r\n        img.src = \"//ssl.gstatic.com/onebox/weather/48/sunny.png\"\r\n      } else if (day.precip > 0 & day.snow == 0) {\r\n        img.src = \"//ssl.gstatic.com/onebox/weather/48/rain.png\"\r\n      } else if (day.precip == 0 & day.snow > 0) {\r\n        img.src = \"//ssl.gstatic.com/onebox/weather/48/snow_light.png\"\r\n      } else if (day.precip > 0 & day.snow > 0) {\r\n        img.src = \"//ssl.gstatic.com/onebox/weather/48/snow_s_rain.png\"\r\n      }\r\n    \r\n      let minTemp = document.createElement('h3');\r\n      minTemp.innerHTML = `Avg Low:${Math.trunc(minAverage)}°C`;\r\n      minTemp.id = \"minTemp\";\r\n      let maxTemp = document.createElement('h3');\r\n      maxTemp.innerHTML = `Avg High:${Math.trunc(maxAverage)}°C`;\r\n      maxTemp.id = \"maxTemp\"\r\n      card.appendChild(date);\r\n      card.appendChild(img);\r\n      card.appendChild(minTemp);\r\n      card.appendChild(maxTemp);\r\n      div.appendChild(card);\r\n    } else {\r\n      let day = data.data[0]\r\n      let div = document.getElementById('weather');\r\n      let card = document.createElement('div');\r\n      card.classList.add('cards');\r\n      let date = document.createElement('h3');\r\n      date.id = \"date\";\r\n      date.innerHTML = day.datetime;\r\n      let img = document.createElement('img');\r\n    \r\n      if (day.precip == 0 & day.snow == 0) {\r\n        img.src = \"//ssl.gstatic.com/onebox/weather/48/sunny.png\"\r\n      } else if (day.precip > 0 & day.snow == 0) {\r\n        img.src = \"//ssl.gstatic.com/onebox/weather/48/rain.png\"\r\n      } else if (day.precip == 0 & day.snow > 0) {\r\n        img.src = \"//ssl.gstatic.com/onebox/weather/48/snow_light.png\"\r\n      } else if (day.precip > 0 & day.snow > 0) {\r\n        img.src = \"//ssl.gstatic.com/onebox/weather/48/snow_s_rain.png\"\r\n      }\r\n    \r\n      let temperature = document.createElement('h3');\r\n      temperature.innerHTML = `Temp:${day.temp}°C`;\r\n      temperature.id = \"temp\"\r\n      card.appendChild(date);\r\n      card.appendChild(img);\r\n      card.appendChild(temperature);\r\n      div.appendChild(card);\r\n    }\r\n  };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import '../styles/main.scss'\r\n\r\nimport { pixUpdate } from './pixUpdate';\r\nimport { weatherUpdate } from './weatherUpdate';\r\nimport { formListener } from './listener';\r\n\r\n//Imported EventListener that runs weatherUpdate\r\ndocument.addEventListener('DOMContentLoaded', function () {\r\n  formListener(weatherUpdate, pixUpdate);\r\n});"],"names":[],"sourceRoot":""}